/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package web.socket.chat;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

@ServerEndpoint("/endpoint")
public class App {

	private static final Logger LOG = Logger.getLogger(App.class.getName());
	private static final Map<User, Session> registered_clients = new HashMap<>();
	private static final Map<String, User> clients = new HashMap<>();
	
	static {
		clients.put("jo", new User("John","111", "jo"));
		clients.put("bo", new User("Bob","222", "bo"));
		clients.put("do", new User("Dep","333", "do"));
		clients.put("go", new User("Gop","444", "go"));
	}
	
	public App() {
		LOG.setLevel(Level.INFO);
		ConsoleHandler handler = new ConsoleHandler();
		handler.setFormatter(new SimpleFormatter());
		LOG.addHandler(handler);
	}
 

	@OnOpen
	public void connectionOpened(Session session) {
		LOG.log(Level.INFO, "connection opened");
	}

	private User extractClient(String message) {
		MessageParser.messageToData(message);
		User tryUser = MessageParser.extractUser();
		String parsedMessage = MessageParser.extractMessage();
		if (clients.containsKey(tryUser.getLog())) {
			User currentUser = clients.get(tryUser.getLog());
			String pass = currentUser.getPass();
			if (pass.equals(tryUser.getPass())){
				return currentUser;
			}
		}
		return null; 
	}
 
	private void sendMessage(String name, Session s, String msg) {
		try {
			s.getBasicRemote().sendText(name + ":" + msg);
		} catch (IOException e) {
			LOG.log(Level.SEVERE, e.getMessage());
		}
	}
	private void privateResponce(User currUser) {
		String[] privateMessage = MessageParser.extractPrivateMessage();
		String privateUserName = privateMessage[0];
		String privateMessageText = privateMessage[1];
		registered_clients.forEach((k, v) ->{
			if (v.isOpen()) {
				if(k.getName().equals(privateUserName)) {
					sendMessage(currUser.getName(), v, privateMessageText);
				} else if (k.getName().equals(currUser.getName())) {
					sendMessage("You", v, privateMessageText);
				}
			}
		});
	}
	private void toAllResponce(User currUser, Session session) {
		registered_clients.forEach((k, v) ->{
			if (v.isOpen()) {
				if (k.equals(currUser)) {
					sendMessage("You", v, MessageParser.extractMessage());
				} else {
					sendMessage(currUser.getName(), v, MessageParser.extractMessage());
				}
			}
		});
	}
	@OnMessage
	public synchronized void processMessage(Session session, String message) {
		LOG.log(Level.INFO, "received message", message);
		User currentUser = extractClient(message);
		if (Objects.nonNull(currentUser) && !registered_clients.containsValue(currentUser)) {
			registered_clients.put(currentUser, session);
		}
		if (MessageParser.isPrivateMessage()) {
			privateResponce(currentUser);
		} else {
			toAllResponce(currentUser, session);
		}
	}

	@OnClose
	public void connectionClosed(Session session) {
		LOG.log(Level.INFO, "connection closed");
		if (clients.containsKey(session.getId())) {
			clients.remove(session.getId());
		}
	}

}
